/*
 * Copyright(c) Live2D Inc. All rights reserved.
 * 
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at http://live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */


/* {{{autogeneratedwarning}}} */


namespace LIVE2DCUBISMCORE {
    /** Emscripten typings. */
    declare namespace _em {
        var HEAP: Int32Array;
        var IHEAP: Int32Array;
        var FHEAP: Float64Array;
  
        var HEAP8: Int8Array;
        var HEAP16: Int16Array;
        var HEAP32: Int32Array;
        var HEAPU8:  Uint8Array;
        var HEAPU16: Uint16Array;
        var HEAPU32: Uint32Array;
        var HEAPF32: Float32Array;
        var HEAPF64: Float64Array;


        function ccall(ident: string, returnType: string, argTypes: string[], args: any[]): any;
        function cwrap(ident: string, returnType: string, argTypes: string[]): any;
        function Pointer_stringify(ptr: number, length?: number): string;
    }


    /**
     * Emscripten Cubism Core module.
     * 
     * This module is governed by the Live2D Proprietary Software license
     * that can be found at http://live2d.com/eula/live2d-proprietary-software-license-agreement_en.html.
     */
    ///\\\_em_module///\\\


    /** C calls. */
    class _csm {
        {{#ccalls.return}}
        public static {{{name}}}({{{args}}}): {{{returnType}}} {
            return _em.ccall("{{{entry}}}", "{{{returnType}}}", [{{{argTypes}}}], [{{{argNames}}}]);
        }
        {{/ccalls.return}}
        {{#ccalls.void}}
        public static {{{name}}}({{{args}}}) {
            _em.ccall("{{{entry}}}", null, [{{{argTypes}}}], [{{{argNames}}}]);
        }
        {{/ccalls.void}}
    }


    /** Cubism moc. */
    export class Moc {
        /** Creates [[Moc]] from [[ArrayBuffer]].
         * 
         * @param buffer Array buffer
         * 
         * @return [[Moc]] on success; [[null]] otherwise.
         */
        public static fromArrayBuffer(buffer: ArrayBuffer): Moc {
            if (!buffer) {
                return null;
            }
            var moc = new Moc(buffer);
            return (moc._ptr)
                ? moc
                : null;
        }


        /** Releases instance. */
        public _release(): void {
            _csm.free(this._ptr);
            this._ptr = 0;
        }


        /** Native moc. */
        public _ptr : number;


        /**
         * Initializes instance.
         * 
         * @param mocBytes Moc bytes.
         */
        private constructor(mocBytes: ArrayBuffer) {
            // Allocate memory.
            var memory = _csm.mallocMoc(mocBytes.byteLength);
            if (!memory) {
                return;
            }
            // Initialize memory.
            var destination = new Uint8Array(_em.HEAPU8.buffer, memory, mocBytes.byteLength);
            destination.set(new Uint8Array(mocBytes));
            // Revive moc.
            this._ptr = _csm.reviveMocInPlace(memory, mocBytes.byteLength);
            if (!this._ptr) {
                _csm.free(memory);
            }
        }
    }


    /** Cubism model. */
    export class Model
    {
        /** Parameters. */
        public parameters: Parameters;
        /** Parts. */
        public parts: Parts;
        /** Drawables. */
        public drawables: Drawables;


        /**
         * Creates [[Model]] from [[Moc]].
         *
         * @param moc Moc
         * 
         * @return [[Model]] on success; [[null]] otherwise.
         */
        public static fromMoc(moc: Moc): Model {
            var model = new Model(moc);
            return (model._ptr)
                ? model
                : null;
        }


        /** Updates instance. */
        public update(): void {
            _csm.updateModel(this._ptr);
        }

        /** Releases instance. */
        public release(): void {
            _csm.free(this._ptr);
            this._ptr = 0;
        }


        /** Native model. */
        public _ptr : number;


        /**
         * Initializes instance.
         * 
         * @param moc Moc
         */
        private constructor(moc: Moc)
        {
            this._ptr = _csm.mallocModelAndInitialize(moc._ptr);
            if (!this._ptr) {
                return;
            }
            this.parameters = new Parameters(this._ptr);
            this.parts = new Parts(this._ptr);
            this.drawables = new Drawables(this._ptr);
        }
    }

    {{#modelgetterclss}}

    /** {{{clsdoc}}} */
    export class {{{clsname}}} {
        {{#props}}
        /** {{{propdoc}}} */
        public {{{propname}}}: {{{proptstype}}};
        {{/props}}

        {{#funcs}}

        /** {{{funcdoc}}}. */
        public {{{funcname}}}() {
            {{{ccall}}}(this._modelPtr);
        }

        {{/funcs}}
        {{#hasfuncs}}

        /** Native model. */
        private _modelPtr: number;

        {{/hasfuncs}}

        /**
         * Initializes instance.
         *
         * @param modelPtr Native model. 
         */
        public constructor(modelPtr: number) {
            {{#hasfuncs}}
            this._modelPtr = modelPtr;


            {{/hasfuncs}}
            {{#hasarrayprop}}
            var length = 0;
            {{/hasarrayprop}}
            {{#hasarray2prop}}
            var length2: Int32Array = null;
            {{/hasarray2prop}}


            {{#scalarprops}}
            this.{{{propname}}} = {{{propget}}}(modelPtr);
            {{/scalarprops}}

            {{#stringarrayprops}}

            length = {{{propgetlength}}}(modelPtr);
            this.{{{propname}}} = new Array<string>(length);
            var _{{{propname}}} = new Uint32Array(_em.HEAPU32.buffer, {{{propget}}}(modelPtr), length{{{proplengthfactor}}});
            _{{{propname}}}.forEach((p, i) => { this.{{{propname}}}[i] = _em.Pointer_stringify(p)})
            {{/stringarrayprops}}
            {{#scalararrayprops}}

            length = {{{propgetlength}}}(modelPtr);
            this.{{{propname}}} = new {{{proptstype}}}({{{propemheapbuffer}}}, {{{propget}}}(modelPtr), length{{{proplengthfactor}}});
            {{/scalararrayprops}}
            {{#scalararray2props}}

            length = {{{propgetlength}}}(modelPtr);
            length2 = new Int32Array(_em.HEAP32.buffer, {{{propgetlength2}}}(modelPtr), length{{{proplengthfactor}}});
            this.{{{propname}}} = new {{{proptstype}}}(length);
            var _{{{propname}}} = new Uint32Array(_em.HEAPU32.buffer, {{{propget}}}(modelPtr), length{{{proplengthfactor}}});
            _{{{propname}}}.forEach((p, i) => { this.{{{propname}}}[i] = new {{{proparray1tstype}}}({{{propemheapbuffer}}}, p, length2[i]{{{proplength2factor}}})});
            {{/scalararray2props}}
        }
    }

    {{/modelgetterclss}}

    /** Utility functions. */
    export class Utils {
        {{#flags}}
        {{#entries}}
        /**
         * Checks whether flag is set in bitfield.
         * 
         * @param bitfield Bitfield to query against.
         * 
         * @return [[true]] if bit set; [[false]] otherwise
        */
        public static has{{{Flagname}}}Bit(bitfield: number): boolean {
            return (bitfield & (1 << {{{flagindex}}})) == (1 << {{{flagindex}}});
        }
        {{/entries}}
        {{/flags}}
    }
}
